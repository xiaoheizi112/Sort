# 经典排序算法合集

## 项目简介

这是一个使用C语言实现的经典排序算法集合项目，包含了三种基础且重要的排序算法：冒泡排序、堆排序和快速排序。每种算法都提供了完整的实现代码和详细的文档说明，适合学习和参考。

## 项目结构

```
Sort/
├── README.md                 # 项目总览文档
├── Bubble-sort/              # 冒泡排序实现
│   ├── BubbleSort.c         # 基础版本
│   ├── BubbleSort(Plus).c   # 优化版本
│   └── README.md            # 冒泡排序详细文档
├── Heap-sort/               # 堆排序实现
│   ├── HeapSort.c          # 堆排序实现
│   └── README.md           # 堆排序详细文档
└── Quick-sort/             # 快速排序实现
    ├── QuickSort.c         # 快速排序实现
    └── README.md           # 快速排序详细文档
```

## 算法对比

| 算法名称 | 时间复杂度(平均) | 时间复杂度(最坏) | 空间复杂度 | 稳定性 | 特点 |
|---------|-----------------|-----------------|------------|--------|------|
| 冒泡排序 | O(n²) | O(n²) | O(1) | 稳定 | 简单直观，适合小数据量 |
| 堆排序 | O(n log n) | O(n log n) | O(1) | 不稳定 | 高效，适合大数据量 |
| 快速排序 | O(n log n) | O(n²) | O(log n) | 不稳定 | 平均情况最快，应用最广泛 |

## 算法详解

### 1. 冒泡排序 (Bubble Sort)

**核心思想**：通过重复比较相邻元素并交换位置，将较大的元素逐渐"冒泡"到数组末尾。

**实现特点**：
- 基础版本：简单直观的实现，适合初学者理解
- 优化版本：支持升序/降序切换、提前终止优化、无临时变量交换

**适用场景**：
- 数据量较小的情况
- 需要稳定排序的场景
- 教学和学习用途

### 2. 堆排序 (Heap Sort)

**核心思想**：基于堆数据结构，通过构建大顶堆和反复调整堆来实现排序。

**实现特点**：
- 使用数组表示完全二叉树
- 构建大顶堆确保父节点大于子节点
- 通过交换堆顶和末尾元素并重新调整堆

**适用场景**：
- 大数据量排序
- 内存受限的环境
- 需要稳定时间复杂度的场景

### 3. 快速排序 (Quick Sort)

**核心思想**：采用分治法，选择基准元素将数组分为两部分，递归排序子数组。

**实现特点**：
- 原地排序，空间效率高
- 平均情况下最快的排序算法
- 使用随机数据生成进行测试

**适用场景**：
- 大多数通用排序场景
- 大数据量排序
- 对性能要求较高的应用

## 编译和运行指南

### 环境要求
- C语言编译器（如GCC）
- 支持标准C库的运行环境

### 编译命令

#### 冒泡排序
```bash
# 基础版本
gcc Bubble-sort/BubbleSort.c -o bubblesort

# 优化版本
gcc "Bubble-sort/BubbleSort(Plus).c" -o bubblesort_plus
```

#### 堆排序
```bash
gcc Heap-sort/HeapSort.c -o heapsort
```

#### 快速排序
```bash
gcc Quick-sort/QuickSort.c -o quicksort
```

### 运行示例

```bash
# 运行冒泡排序基础版本
./bubblesort

# 运行冒泡排序优化版本
./bubblesort_plus

# 运行堆排序
./heapsort

# 运行快速排序
./quicksort
```